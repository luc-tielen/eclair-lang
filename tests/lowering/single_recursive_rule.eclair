// RUN: split-file %s %t

// RUN: %eclair compile --emit ra %t/program.eclair > %t/actual_ra.out
// RUN: diff %t/expected_ra.out %t/actual_ra.out

// NOTE: program for now also contains delta_ and new_ relations,
// probably it's more efficient to move these to the stack (but left out of scope for now)
// RUN: %eclair compile --emit eir %t/program.eclair > %t/actual_eir.out
// RUN: diff %t/expected_eir.out %t/actual_eir.out

// RUN: %eclair compile --emit llvm %t/program.eclair > %t/actual_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "program = " > %t/actual_eclair_program_type.out
// RUN: %extract_snippet %t/actual_llvm.out "@eclair_program_init" > %t/actual_eclair_program_init_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "@eclair_program_destroy" > %t/actual_eclair_program_destroy_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "@eclair_program_run" > %t/actual_eclair_program_run_llvm.out
// RUN: diff %t/expected_eclair_program_type.out %t/actual_eclair_program_type.out
// RUN: diff %t/expected_eclair_program_init_llvm.out %t/actual_eclair_program_init_llvm.out
// RUN: diff %t/expected_eclair_program_destroy_llvm.out %t/actual_eclair_program_destroy_llvm.out
// RUN: diff %t/expected_eclair_program_run_llvm.out %t/actual_eclair_program_run_llvm.out

//--- program.eclair
@def edge(u32, u32).
@def path(u32, u32) output.

edge(1,2).

path(x, y) :-
  edge(x, z),
  path(z, y).

//--- expected_ra.out
project (1, 2) into edge
merge path delta_path
loop do
  purge new_path
  search edge as edge0 do
    search delta_path as delta_path1 where (delta_path1[0] = edge0[1] and (edge0[0], delta_path1[1]) âˆ‰ path) do
      project (edge0[0], delta_path1[1]) into new_path
  exit if counttuples(new_path) = 0
  merge new_path path
  swap new_path delta_path
//--- expected_eir.out
declare_type Program
{
  symbol_table
  delta_path btree(num_columns=2, index=[0,1], block_size=256, search_type=linear)
  edge btree(num_columns=2, index=[0,1], block_size=256, search_type=linear)
  new_path btree(num_columns=2, index=[0,1], block_size=256, search_type=linear)
  path btree(num_columns=2, index=[0,1], block_size=256, search_type=linear)
}

export fn eclair_program_init() -> *Program
{
  program = heap_allocate_program
  symbol_table.init(program.0)
  delta_path.init_empty(program.1)
  edge.init_empty(program.2)
  new_path.init_empty(program.3)
  path.init_empty(program.4)
  symbol_table.insert(program.0, edge)
  symbol_table.insert(program.0, path)
  return program
}

export fn eclair_program_destroy(*Program) -> Void
{
  symbol_table.destroy(FN_ARG[0].0)
  delta_path.destroy(FN_ARG[0].1)
  edge.destroy(FN_ARG[0].2)
  new_path.destroy(FN_ARG[0].3)
  path.destroy(FN_ARG[0].4)
  free_program(FN_ARG[0])
}

export fn eclair_program_run(*Program) -> Void
{
  value = edge.stack_allocate Value
  value.0 = 1
  value.1 = 2
  edge.insert(FN_ARG[0].2, value)
  begin_iter = path.stack_allocate Iter
  end_iter = path.stack_allocate Iter
  path.iter_begin(FN_ARG[0].4, begin_iter)
  path.iter_end(FN_ARG[0].4, end_iter)
  delta_path.insert_range<path[0, 1]>(FN_ARG[0].1, begin_iter, end_iter)
  loop
  {
    new_path.purge(FN_ARG[0].3)
    value_1 = edge.stack_allocate Value
    value_1.0 = 0
    value_1.1 = 0
    value_2 = edge.stack_allocate Value
    value_2.0 = 4294967295
    value_2.1 = 4294967295
    begin_iter_1 = edge.stack_allocate Iter
    end_iter_1 = edge.stack_allocate Iter
    edge.iter_lower_bound(FN_ARG[0].2, value_1, begin_iter_1)
    edge.iter_upper_bound(FN_ARG[0].2, value_2, end_iter_1)
    loop
    {
      condition = edge.iter_is_equal(begin_iter_1, end_iter_1)
      if (condition)
      {
        goto range_query.end
      }
      current = edge.iter_current(begin_iter_1)
      value_3 = path.stack_allocate Value
      value_3.0 = current.1
      value_3.1 = 0
      value_4 = path.stack_allocate Value
      value_4.0 = current.1
      value_4.1 = 4294967295
      begin_iter_2 = path.stack_allocate Iter
      end_iter_2 = path.stack_allocate Iter
      delta_path.iter_lower_bound(FN_ARG[0].1, value_3, begin_iter_2)
      delta_path.iter_upper_bound(FN_ARG[0].1, value_4, end_iter_2)
      loop
      {
        condition_1 = delta_path.iter_is_equal(begin_iter_2, end_iter_2)
        if (condition_1)
        {
          goto range_query.end_1
        }
        current_1 = delta_path.iter_current(begin_iter_2)
        value_5 = path.stack_allocate Value
        value_5.0 = current.0
        value_5.1 = current_1.1
        contains_result = path.contains(FN_ARG[0].4, value_5)
        condition_2 = not contains_result
        if (condition_2)
        {
          value_6 = path.stack_allocate Value
          value_6.0 = current.0
          value_6.1 = current_1.1
          new_path.insert(FN_ARG[0].3, value_6)
        }
        delta_path.iter_next(begin_iter_2)
      }
      range_query.end_1:
      edge.iter_next(begin_iter_1)
    }
    range_query.end:
    condition_3 = new_path.is_empty(FN_ARG[0].3)
    if (condition_3)
    {
      goto loop.end
    }
    begin_iter_3 = path.stack_allocate Iter
    end_iter_3 = path.stack_allocate Iter
    new_path.iter_begin(FN_ARG[0].3, begin_iter_3)
    new_path.iter_end(FN_ARG[0].3, end_iter_3)
    path.insert_range<new_path[0, 1]>(FN_ARG[0].4, begin_iter_3, end_iter_3)
    new_path.swap(FN_ARG[0].3, FN_ARG[0].1)
  }
  loop.end:
}
//--- expected_eclair_program_type.out
%program = type {%symbol_table, %btree_t_0, %btree_t_0, %btree_t_0, %btree_t_0}
//--- expected_eclair_program_init_llvm.out
define external ccc %program* @eclair_program_init() "wasm-export-name"="eclair_program_init" {
start:
  %memory_0 = call ccc i8* @malloc(i32 1624)
  %program_0 = bitcast i8* %memory_0 to %program*
  %0 = getelementptr %program, %program* %program_0, i32 0, i32 0
  call ccc void @symbol_table_init(%symbol_table* %0)
  %1 = getelementptr %program, %program* %program_0, i32 0, i32 1
  call ccc void @btree_init_empty_0(%btree_t_0* %1)
  %2 = getelementptr %program, %program* %program_0, i32 0, i32 2
  call ccc void @btree_init_empty_0(%btree_t_0* %2)
  %3 = getelementptr %program, %program* %program_0, i32 0, i32 3
  call ccc void @btree_init_empty_0(%btree_t_0* %3)
  %4 = getelementptr %program, %program* %program_0, i32 0, i32 4
  call ccc void @btree_init_empty_0(%btree_t_0* %4)
  %5 = getelementptr %program, %program* %program_0, i32 0, i32 0
  %6 = getelementptr inbounds [5 x i8], [5 x i8]* @string_literal_0, i32 0, i32 0
  %7 = zext i32 4 to i64
  %8 = call ccc i8* @malloc(i32 4)
  call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %6, i64 %7, i1 0)
  %9 = alloca %symbol_t, i32 1
  call ccc void @symbol_init(%symbol_t* %9, i32 4, i8* %8)
  %10 = call ccc i32 @symbol_table_find_or_insert(%symbol_table* %5, %symbol_t* %9)
  %11 = getelementptr %program, %program* %program_0, i32 0, i32 0
  %12 = getelementptr inbounds [5 x i8], [5 x i8]* @string_literal_1, i32 0, i32 0
  %13 = zext i32 4 to i64
  %14 = call ccc i8* @malloc(i32 4)
  call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %12, i64 %13, i1 0)
  %15 = alloca %symbol_t, i32 1
  call ccc void @symbol_init(%symbol_t* %15, i32 4, i8* %14)
  %16 = call ccc i32 @symbol_table_find_or_insert(%symbol_table* %11, %symbol_t* %15)
  ret %program* %program_0
}
//--- expected_eclair_program_destroy_llvm.out
define external ccc void @eclair_program_destroy(%program* %arg_0) "wasm-export-name"="eclair_program_destroy" {
start:
  %0 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  call ccc void @symbol_table_destroy(%symbol_table* %0)
  %1 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_destroy_0(%btree_t_0* %1)
  %2 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_destroy_0(%btree_t_0* %2)
  %3 = getelementptr %program, %program* %arg_0, i32 0, i32 3
  call ccc void @btree_destroy_0(%btree_t_0* %3)
  %4 = getelementptr %program, %program* %arg_0, i32 0, i32 4
  call ccc void @btree_destroy_0(%btree_t_0* %4)
  %memory_0 = bitcast %program* %arg_0 to i8*
  call ccc void @free(i8* %memory_0)
  ret void
}
//--- expected_eclair_program_run_llvm.out
define external ccc void @eclair_program_run(%program* %arg_0) "wasm-export-name"="eclair_program_run" {
start:
  %value_0 = alloca [2 x i32], i32 1
  %0 = getelementptr [2 x i32], [2 x i32]* %value_0, i32 0, i32 0
  store i32 1, i32* %0
  %1 = getelementptr [2 x i32], [2 x i32]* %value_0, i32 0, i32 1
  store i32 2, i32* %1
  %2 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %3 = call ccc i1 @btree_insert_value_0(%btree_t_0* %2, [2 x i32]* %value_0)
  %begin_iter_0 = alloca %btree_iterator_t_0, i32 1
  %end_iter_0 = alloca %btree_iterator_t_0, i32 1
  %4 = getelementptr %program, %program* %arg_0, i32 0, i32 4
  call ccc void @btree_begin_0(%btree_t_0* %4, %btree_iterator_t_0* %begin_iter_0)
  %5 = getelementptr %program, %program* %arg_0, i32 0, i32 4
  call ccc void @btree_end_0(%btree_t_0* %5, %btree_iterator_t_0* %end_iter_0)
  %6 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_insert_range_delta_path_path(%btree_t_0* %6, %btree_iterator_t_0* %begin_iter_0, %btree_iterator_t_0* %end_iter_0)
  br label %loop_0
loop_0:
  %7 = getelementptr %program, %program* %arg_0, i32 0, i32 3
  call ccc void @btree_clear_0(%btree_t_0* %7)
  %value_1_0 = alloca [2 x i32], i32 1
  %8 = getelementptr [2 x i32], [2 x i32]* %value_1_0, i32 0, i32 0
  store i32 0, i32* %8
  %9 = getelementptr [2 x i32], [2 x i32]* %value_1_0, i32 0, i32 1
  store i32 0, i32* %9
  %value_2_0 = alloca [2 x i32], i32 1
  %10 = getelementptr [2 x i32], [2 x i32]* %value_2_0, i32 0, i32 0
  store i32 4294967295, i32* %10
  %11 = getelementptr [2 x i32], [2 x i32]* %value_2_0, i32 0, i32 1
  store i32 4294967295, i32* %11
  %begin_iter_1_0 = alloca %btree_iterator_t_0, i32 1
  %end_iter_1_0 = alloca %btree_iterator_t_0, i32 1
  %12 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_lower_bound_0(%btree_t_0* %12, [2 x i32]* %value_1_0, %btree_iterator_t_0* %begin_iter_1_0)
  %13 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_upper_bound_0(%btree_t_0* %13, [2 x i32]* %value_2_0, %btree_iterator_t_0* %end_iter_1_0)
  br label %loop_1
loop_1:
  %condition_0 = call ccc i1 @btree_iterator_is_equal_0(%btree_iterator_t_0* %begin_iter_1_0, %btree_iterator_t_0* %end_iter_1_0)
  br i1 %condition_0, label %if_0, label %end_if_0
if_0:
  br label %range_query.end
end_if_0:
  %current_0 = call ccc [2 x i32]* @btree_iterator_current_0(%btree_iterator_t_0* %begin_iter_1_0)
  %value_3_0 = alloca [2 x i32], i32 1
  %14 = getelementptr [2 x i32], [2 x i32]* %value_3_0, i32 0, i32 0
  %15 = getelementptr [2 x i32], [2 x i32]* %current_0, i32 0, i32 1
  %16 = load i32, i32* %15
  store i32 %16, i32* %14
  %17 = getelementptr [2 x i32], [2 x i32]* %value_3_0, i32 0, i32 1
  store i32 0, i32* %17
  %value_4_0 = alloca [2 x i32], i32 1
  %18 = getelementptr [2 x i32], [2 x i32]* %value_4_0, i32 0, i32 0
  %19 = getelementptr [2 x i32], [2 x i32]* %current_0, i32 0, i32 1
  %20 = load i32, i32* %19
  store i32 %20, i32* %18
  %21 = getelementptr [2 x i32], [2 x i32]* %value_4_0, i32 0, i32 1
  store i32 4294967295, i32* %21
  %begin_iter_2_0 = alloca %btree_iterator_t_0, i32 1
  %end_iter_2_0 = alloca %btree_iterator_t_0, i32 1
  %22 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_lower_bound_0(%btree_t_0* %22, [2 x i32]* %value_3_0, %btree_iterator_t_0* %begin_iter_2_0)
  %23 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_upper_bound_0(%btree_t_0* %23, [2 x i32]* %value_4_0, %btree_iterator_t_0* %end_iter_2_0)
  br label %loop_2
loop_2:
  %condition_1_0 = call ccc i1 @btree_iterator_is_equal_0(%btree_iterator_t_0* %begin_iter_2_0, %btree_iterator_t_0* %end_iter_2_0)
  br i1 %condition_1_0, label %if_1, label %end_if_1
if_1:
  br label %range_query.end_1
end_if_1:
  %current_1_0 = call ccc [2 x i32]* @btree_iterator_current_0(%btree_iterator_t_0* %begin_iter_2_0)
  %value_5_0 = alloca [2 x i32], i32 1
  %24 = getelementptr [2 x i32], [2 x i32]* %value_5_0, i32 0, i32 0
  %25 = getelementptr [2 x i32], [2 x i32]* %current_0, i32 0, i32 0
  %26 = load i32, i32* %25
  store i32 %26, i32* %24
  %27 = getelementptr [2 x i32], [2 x i32]* %value_5_0, i32 0, i32 1
  %28 = getelementptr [2 x i32], [2 x i32]* %current_1_0, i32 0, i32 1
  %29 = load i32, i32* %28
  store i32 %29, i32* %27
  %contains_result_0 = getelementptr %program, %program* %arg_0, i32 0, i32 4
  %contains_result_1 = call ccc i1 @btree_contains_0(%btree_t_0* %contains_result_0, [2 x i32]* %value_5_0)
  %condition_2_0 = select i1 %contains_result_1, i1 0, i1 1
  br i1 %condition_2_0, label %if_2, label %end_if_2
if_2:
  %value_6_0 = alloca [2 x i32], i32 1
  %30 = getelementptr [2 x i32], [2 x i32]* %value_6_0, i32 0, i32 0
  %31 = getelementptr [2 x i32], [2 x i32]* %current_0, i32 0, i32 0
  %32 = load i32, i32* %31
  store i32 %32, i32* %30
  %33 = getelementptr [2 x i32], [2 x i32]* %value_6_0, i32 0, i32 1
  %34 = getelementptr [2 x i32], [2 x i32]* %current_1_0, i32 0, i32 1
  %35 = load i32, i32* %34
  store i32 %35, i32* %33
  %36 = getelementptr %program, %program* %arg_0, i32 0, i32 3
  %37 = call ccc i1 @btree_insert_value_0(%btree_t_0* %36, [2 x i32]* %value_6_0)
  br label %end_if_2
end_if_2:
  call ccc void @btree_iterator_next_0(%btree_iterator_t_0* %begin_iter_2_0)
  br label %loop_2
range_query.end_1:
  call ccc void @btree_iterator_next_0(%btree_iterator_t_0* %begin_iter_1_0)
  br label %loop_1
range_query.end:
  %condition_3_0 = getelementptr %program, %program* %arg_0, i32 0, i32 3
  %condition_3_1 = call ccc i1 @btree_is_empty_0(%btree_t_0* %condition_3_0)
  br i1 %condition_3_1, label %if_3, label %end_if_3
if_3:
  br label %loop.end
end_if_3:
  %begin_iter_3_0 = alloca %btree_iterator_t_0, i32 1
  %end_iter_3_0 = alloca %btree_iterator_t_0, i32 1
  %38 = getelementptr %program, %program* %arg_0, i32 0, i32 3
  call ccc void @btree_begin_0(%btree_t_0* %38, %btree_iterator_t_0* %begin_iter_3_0)
  %39 = getelementptr %program, %program* %arg_0, i32 0, i32 3
  call ccc void @btree_end_0(%btree_t_0* %39, %btree_iterator_t_0* %end_iter_3_0)
  %40 = getelementptr %program, %program* %arg_0, i32 0, i32 4
  call ccc void @btree_insert_range_path_new_path(%btree_t_0* %40, %btree_iterator_t_0* %begin_iter_3_0, %btree_iterator_t_0* %end_iter_3_0)
  %41 = getelementptr %program, %program* %arg_0, i32 0, i32 3
  %42 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_swap_0(%btree_t_0* %41, %btree_t_0* %42)
  br label %loop_0
loop.end:
  ret void
}
